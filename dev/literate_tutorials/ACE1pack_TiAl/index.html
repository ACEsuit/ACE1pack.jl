<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TiAl potential (ACE1pack-julia) · ACE1pack.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://ACEsuit.github.io/ACE1pack.jl/literate_tutorials/ACE1pack_TiAl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ACE1pack.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../gettingstarted/installation/">Installation Instructions</a></li><li><a class="tocitem" href="../../gettingstarted/pkg/">Using the Julia Package Manager</a></li><li><a class="tocitem" href="../../gettingstarted/aceintro/">Introduction to ACE Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials Overview</a></li><li><a class="tocitem" href="../../tutorials/first_example_json/">TiAl potential (command line JSON)</a></li><li><a class="tocitem" href="../first_example/">First example (Julia)</a></li><li><a class="tocitem" href="../TiAl/">Fitting a TiAl potential (Julia)</a></li><li class="is-active"><a class="tocitem" href>TiAl potential (ACE1pack-julia)</a></li><li><a class="tocitem" href="../../tutorials/lammps/">LAMMPS</a></li><li><a class="tocitem" href="../../tutorials/python_ase/">python-<code>ase</code></a></li></ul></li><li><span class="tocitem">Command line</span><ul><li><a class="tocitem" href="../../command_line/">Command line interface</a></li></ul></li><li><span class="tocitem">ACE1pack Internals</span><ul><li><a class="tocitem" href="../../ACE1pack/ace1pack_overview/">Overview</a></li><li><a class="tocitem" href="../../ACE1pack/fit/">Fitting ACE</a></li><li><a class="tocitem" href="../../ACE1pack/helpers/">Helper Functions</a></li><li><a class="tocitem" href="../../ACE1pack/data/">Handling Data</a></li><li><a class="tocitem" href="../../ACE1pack/basis/">Constructing Basis</a></li><li><a class="tocitem" href="../../ACE1pack/solver/">Solvers</a></li><li><a class="tocitem" href="../../ACE1pack/all_exported/">All ACE1pack functions</a></li></ul></li><li><span class="tocitem">IPFitting Internals</span><ul><li><a class="tocitem" href="../../IPFitting/IPFitting/">ACE1 and IPFitting</a></li><li><a class="tocitem" href="../../IPFitting/Solvers/">Least squares solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>TiAl potential (ACE1pack-julia)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TiAl potential (ACE1pack-julia)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ACEsuit/ACE1pack.jl/blob/main/tutorials/ACE1pack_TiAl.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TiAl-potential-(ACE1pack-julia)"><a class="docs-heading-anchor" href="#TiAl-potential-(ACE1pack-julia)">TiAl potential (ACE1pack-julia)</a><a id="TiAl-potential-(ACE1pack-julia)-1"></a><a class="docs-heading-anchor-permalink" href="#TiAl-potential-(ACE1pack-julia)" title="Permalink"></a></h1><p>In this tutorial we repeat what was done in [Fitting a TiAL potential][TiAl.md], but only using ACE1pack.</p><p><code>ACE1pack.jl</code> has two purposes: (1) to import and re-export <code>ACE1.jl</code>, <code>IPFitting.jl</code>, <code>JuLIP.jl</code> with guaranteed version compatibility; and (2) to have several convenience wrappers for setting up the least-squares problem (<code>ACE1.jl</code> &amp; <code>JuLIP.jl</code>) and solving it (<code>IPFitting.jl</code>). For full documentation see <a href="../../ACE1pack/ace1pack_overview/">ACE1pak overview</a>.</p><p>First import ACE1pack</p><pre><code class="language-julia hljs">using ACE1pack</code></pre><p>First, we need to construct various parameters&#39; dictionaries that define various aspects of fitting an ACE potential. We use various <code>*params()</code> functions that return these dictionaries and let us only specify mandatory and non-default parameter values.</p><pre><code class="language-julia hljs">data_param_dict = data_params(
    fname = joinpath(ACE1pack.artifact(&quot;TiAl_tutorial&quot;), &quot;TiAl_tutorial.xyz&quot;),
    energy_key = &quot;energy&quot;,
    force_key = &quot;force&quot;,
    virial_key = &quot;virial&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 4 entries:
  &quot;force_key&quot;  =&gt; &quot;force&quot;
  &quot;energy_key&quot; =&gt; &quot;energy&quot;
  &quot;fname&quot;      =&gt; &quot;/home/runner/.julia/artifacts/b437d7d5fac4424b8203d0afc31732…
  &quot;virial_key&quot; =&gt; &quot;virial&quot;</code></pre><p>N.B. there is no way to sub-select data (should there be?) and here this tutorial diverges from [Fitting a TiAL potential][TiAl.md], but the the .xyz file is small enough.</p><pre><code class="language-julia hljs">r0 = 2.88
species = [&quot;Ti&quot;, &quot;Al&quot;]     # symbols (:Ti, :Al) also work</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;Ti&quot;
 &quot;Al&quot;</code></pre><p><code>basis_params</code> of <code>type=&quot;ace&quot;</code> can optionally have radial part defined.</p><pre><code class="language-julia hljs">ace_radial_params = basis_params(
    type = &quot;radial&quot;,
    r0 = r0,
    rin = 0.6 * r0,
    rcut = 5.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 5 entries:
  &quot;rcut&quot; =&gt; 5.5
  &quot;rin&quot;  =&gt; 1.728
  &quot;pin&quot;  =&gt; 2
  &quot;pcut&quot; =&gt; 2
  &quot;type&quot; =&gt; &quot;radial&quot;</code></pre><p>Construct ACE basis</p><pre><code class="language-julia hljs">ACE_basis_param_dict = basis_params(
    type = &quot;ace&quot;,
    species = species,
    N = 3,
    maxdeg = 6,
    r0 = r0,
    radial = ace_radial_params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 7 entries:
  &quot;N&quot;         =&gt; 3
  &quot;maxdeg&quot;    =&gt; 6
  &quot;radial&quot;    =&gt; Dict{String, Any}(&quot;rcut&quot;=&gt;5.5, &quot;rin&quot;=&gt;1.728, &quot;pin&quot;=&gt;2, &quot;pcut&quot;=…
  &quot;degree&quot;    =&gt; Dict{String, Any}(&quot;csp&quot;=&gt;1.0, &quot;chc&quot;=&gt;0.0, &quot;wL&quot;=&gt;1.5, &quot;bhc&quot;=&gt;0.…
  &quot;type&quot;      =&gt; &quot;ace&quot;
  &quot;transform&quot; =&gt; Dict{String, Any}(&quot;r0&quot;=&gt;2.88, &quot;type&quot;=&gt;&quot;polynomial&quot;, &quot;p&quot;=&gt;2)
  &quot;species&quot;   =&gt; [&quot;Ti&quot;, &quot;Al&quot;]</code></pre><p>and pair basis.</p><pre><code class="language-julia hljs">pair_basis_param_dict = basis_params(
    type = &quot;pair&quot;,
    species = species,
    maxdeg = 6,
    r0 = r0,
    rcut = 7.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 8 entries:
  &quot;rcut&quot;      =&gt; 7.0
  &quot;rin&quot;       =&gt; 0.0
  &quot;maxdeg&quot;    =&gt; 6
  &quot;pin&quot;       =&gt; 0
  &quot;pcut&quot;      =&gt; 2
  &quot;type&quot;      =&gt; &quot;pair&quot;
  &quot;transform&quot; =&gt; Dict{String, Any}(&quot;r0&quot;=&gt;2.88, &quot;type&quot;=&gt;&quot;polynomial&quot;, &quot;p&quot;=&gt;2)
  &quot;species&quot;   =&gt; [&quot;Ti&quot;, &quot;Al&quot;]</code></pre><p>The keys in the following dictionary are for reference, the basis function kind is defined by the <code>type</code> parameter. This way, it&#39;s possible to specify multiple &quot;ACE&quot; and/or &quot;pair&quot;, etc basis.</p><pre><code class="language-julia hljs">basis_param_dicts = Dict(
    &quot;pair&quot; =&gt; pair_basis_param_dict,
    &quot;ace&quot; =&gt; ACE_basis_param_dict)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Dict{String, Any}} with 2 entries:
  &quot;ace&quot;  =&gt; Dict(&quot;N&quot;=&gt;3, &quot;maxdeg&quot;=&gt;6, &quot;radial&quot;=&gt;Dict{String, Any}(&quot;rcut&quot;=&gt;5.5, …
  &quot;pair&quot; =&gt; Dict(&quot;rcut&quot;=&gt;7.0, &quot;rin&quot;=&gt;0.0, &quot;maxdeg&quot;=&gt;6, &quot;pin&quot;=&gt;0, &quot;pcut&quot;=&gt;2, &quot;ty…</code></pre><p>We also need to give the &quot;isolated atom&quot; energies that will be subtracted from total energies before the fit.</p><pre><code class="language-julia hljs">e0 = Dict(
    &quot;Ti&quot; =&gt; -1586.0195,
    &quot;Al&quot; =&gt;  -105.5954)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Float64} with 2 entries:
  &quot;Ti&quot; =&gt; -1586.02
  &quot;Al&quot; =&gt; -105.595</code></pre><p>weights are given in a dictionary as before</p><pre><code class="language-julia hljs">weights = Dict(
        &quot;FLD_TiAl&quot; =&gt; Dict(&quot;E&quot; =&gt; 30.0, &quot;F&quot; =&gt; 1.0 , &quot;V&quot; =&gt; 1.0 ),
        &quot;TiAl_T5000&quot; =&gt; Dict(&quot;E&quot; =&gt; 5.0, &quot;F&quot; =&gt; 1.0 , &quot;V&quot; =&gt; 1.0 ))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Dict{String, Float64}} with 2 entries:
  &quot;FLD_TiAl&quot;   =&gt; Dict(&quot;V&quot;=&gt;1.0, &quot;E&quot;=&gt;30.0, &quot;F&quot;=&gt;1.0)
  &quot;TiAl_T5000&quot; =&gt; Dict(&quot;V&quot;=&gt;1.0, &quot;E&quot;=&gt;5.0, &quot;F&quot;=&gt;1.0)</code></pre><p>The fit will be done using LSQR solver. <code>lsqr_atol</code> has a default value of 1e-6, so we can skip it here.</p><pre><code class="language-julia hljs">solver_param_dict = solver_params(
    type = &quot;lsqr&quot;,
    lsqr_damp = 1e-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 6 entries:
  &quot;lsqr_atol&quot;    =&gt; 1.0e-6
  &quot;lsqr_damp&quot;    =&gt; 0.01
  &quot;lsqr_conlim&quot;  =&gt; 1.0e8
  &quot;type&quot;         =&gt; &quot;lsqr&quot;
  &quot;lsqr_maxiter&quot; =&gt; 100000
  &quot;lsqr_verbose&quot; =&gt; false</code></pre><p>and define parameters for smoothness prior.</p><pre><code class="language-julia hljs">smoothness_prior_params = regularizer_params(
    type = &quot;laplacian&quot;,
    rlap_scal = 3.0)        # default</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 2 entries:
  &quot;rlap_scal&quot; =&gt; 3.0
  &quot;type&quot;      =&gt; &quot;laplacian&quot;</code></pre><p>Finally, let&#39;s upt everything together. Note that exporting to <code>pacemaker</code> code isn&#39;t supported (should it be?).</p><pre><code class="language-julia hljs">ace_fit_params = fit_params(
    data = data_param_dict,
    basis = basis_param_dicts,
    solver = solver_param_dict,
    e0 = e0,
    weights = weights,
    P = smoothness_prior_params,
    ACE_fname = &quot;ACE.json&quot;  # change to `nothing` if you don&#39;t want to save the potential
)

fitted_potential, lsqinfo = ACE1pack.fit_ace(ace_fit_params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(JuLIP.MLIPs.SumIP{Any}(Any[OneBody{Float64}(Dict(:Al =&gt; -105.5954, :Ti =&gt; -1586.0195)), PIPotential{Float64, 2, PIBasis{BasicPSH1pBasis{Float64, 2, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}}, 2, ACE1.DAGEvaluator}, ACE1.DAGEvaluator}(PIBasis{BasicPSH1pBasis{Float64, 2, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}}, 2, ACE1.DAGEvaluator}(BasicPSH1pBasis{Float64, 2, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}}(ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.3563171597633136, 2, 2.022901419836431, [3.253577614437167, 3.980146542617523, 3.208896730258186, 2.9171788456892846, 2.7660000991755456, 2.675144850592528], [0.0, -4.73481930186265, -3.8173333603235693, -3.470303054839645, -3.2904594135665928, -3.1823771658251663], [0.0, 0.0, -0.8062257748298494, -0.9090909090909298, -0.948176387355483, -0.967152839723303], [0.35715045189335015, 0.35881703615342325, 0.3604836204134964, 0.3621502046735695, 0.3638167889336426, 0.3654833731937157, 0.36714995745378887, 0.36881654171386197, 0.37048312597393507, 0.3721497102340082  …  2.007068869365736, 2.0087354536258095, 2.0104020378858825, 2.012068622145956, 2.0137352064060288, 2.0154017906661017, 2.017068374926175, 2.018734959186248, 2.0204015434463214, 2.0220681277063943], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88), 1.728, 5.5), ACE1.SphericalHarmonics.SHBasis{Float64}(3, ACE1.SphericalHarmonics.ALPCoefficients{Float64}([0.0, 6.91810596825517e-310, 6.91810596684095e-310, 1.9364916731037085, 6.91810596825517e-310, 6.91810596684095e-310, 1.9720265943665387, 2.091650066335189, 6.91810596684095e-310, 0.0], [0.0, 6.91810596825517e-310, 6.91810672635187e-310, -0.5773502691896257, 6.91810596825517e-310, 6.91810596684095e-310, -0.5163977794943222, -0.4472135954999579, 6.91810596684095e-310, 0.0])), JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), ACE1.RPI.PSH1pBasisFcn[znlm[0|1,0,0], znlm[0|1,1,-1], znlm[0|1,1,0], znlm[0|1,1,1], znlm[0|1,2,-2], znlm[0|1,2,-1], znlm[0|1,2,0], znlm[0|1,2,1], znlm[0|1,2,2], znlm[0|1,3,-3]  …  znlm[0|3,2,-1], znlm[0|3,2,0], znlm[0|3,2,1], znlm[0|3,2,2], znlm[0|4,0,0], znlm[0|4,1,-1], znlm[0|4,1,0], znlm[0|4,1,1], znlm[0|5,0,0], znlm[0|6,0,0]], UnitRange{Int64}[1:40 1:40; 41:80 41:80]), JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), (ACE1.InnerPIBasis([1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [1 0 0; 17 0 0; … ; 41 57 66; 57 57 57], Dict{ACE1.PIBasisFcn, Int64}(ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[22|4,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 25, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,1,0], znlm[13|1,1,0], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 112, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[13|2,2,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 16, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|2,0,0], znlm[22|2,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 123, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 22, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[22|1,1,1], znlm[22|2,1,-1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 71, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,1,1], znlm[13|2,1,-1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 35, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[22|1,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 62, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[13|2,0,0], znlm[13|3,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 94, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,1,0], znlm[22|1,0,0], znlm[22|1,1,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 113…), Dict{Any, Int64}(znlm[22|3,0,0] =&gt; 66, znlm[13|1,3,0] =&gt; 13, znlm[13|2,2,2] =&gt; 25, znlm[13|1,2,0] =&gt; 7, znlm[22|2,2,2] =&gt; 65, znlm[13|1,2,-1] =&gt; 6, znlm[13|2,1,-1] =&gt; 18, znlm[13|3,2,-1] =&gt; 31, znlm[13|2,2,-2] =&gt; 21, znlm[13|5,0,0] =&gt; 39…), 1:136, &lt;13&gt;, ACE1.DAG.CorrEvalGraph{Int64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0  …  127, 128, 129, 130, 131, 132, 133, 134, 135, 136], 80, 104)), ACE1.InnerPIBasis([1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [1 0 0; 17 0 0; … ; 41 57 66; 57 57 57], Dict{ACE1.PIBasisFcn, Int64}(ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,0,0], znlm[13|3,0,0], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 98, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[22|1,0,0], znlm[22|1,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 129, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,1,-1], znlm[13|1,1,1], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 110, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,1,-1], znlm[22|1,0,0], znlm[22|1,1,1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 111, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,0,0], znlm[13|2,0,0], znlm[13|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 93, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[22|1,1,1], znlm[22|2,1,-1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 71, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[22|1,1,0], znlm[22|2,1,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 70, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,0,0], znlm[22|1,1,-1], znlm[22|1,1,1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 106, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,0,0], znlm[13|4,0,0], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 100, ACE1.PIBasisFcn{1, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[22|4,0,0],), ACE1.RPI.PSH1pBasisFcn) =&gt; 10…), Dict{Any, Int64}(znlm[22|3,0,0] =&gt; 66, znlm[13|1,3,0] =&gt; 13, znlm[13|2,2,2] =&gt; 25, znlm[13|1,2,0] =&gt; 7, znlm[22|2,2,2] =&gt; 65, znlm[13|1,2,-1] =&gt; 6, znlm[13|2,1,-1] =&gt; 18, znlm[13|3,2,-1] =&gt; 31, znlm[13|2,2,-2] =&gt; 21, znlm[13|5,0,0] =&gt; 39…), 137:272, &lt;22&gt;, ACE1.DAG.CorrEvalGraph{Int64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0  …  127, 128, 129, 130, 131, 132, 133, 134, 135, 136], 80, 104))), ACE1.DAGEvaluator()), ([-10.989498049255403, 2.1663478824986044, -0.11867221259592667, -0.1803199617739813, -0.14068308401103413, -0.028990296492123247, 0.3705685723582922, 1.2158300262208281, 0.1932456455720456, 0.012217956259533449  …  -0.01955587400668855, 0.0, 0.2191399318648039, 0.029204898298027422, -0.0004334725421019836, -0.47040074348389505, 0.23520037174194747, 0.37436163541210954, 0.09780145230117288, -0.05040412514624649], [0.3705685723746492, 1.2158300262209565, 0.19324564557208737, 0.012217956259542652, 0.014945863672143796, 0.1650289798709044, 4.248156060904366, 0.9566626648476521, 0.09290935110469016, -0.003100186832185328  …  0.009964557255347811, 0.0, -0.16865473044441018, -0.012707832390643447, 0.0020863581530302074, 0.19244885352310304, -0.09622442676155149, -0.047502048829633506, -0.06589403960413397, 0.0063015742808691065]), (ACE1.DAG.CorrEvalGraph{Float64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [-10.989498049255403, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  -0.01955587400668855, 0.0, 0.2191399318648039, 0.029204898298027422, -0.0004334725421019836, -0.47040074348389505, 0.23520037174194747, 0.37436163541210954, 0.09780145230117288, -0.05040412514624649], 80, 104), ACE1.DAG.CorrEvalGraph{Float64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [0.3705685723746492, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.009964557255347811, 0.0, -0.16865473044441018, -0.012707832390643447, 0.0020863581530302074, 0.19244885352310304, -0.09622442676155149, -0.047502048829633506, -0.06589403960413397, 0.0063015742808691065], 80, 104)), ACE1.DAGEvaluator()), PolyPairPot{Float64, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}, 2}([264.9484228860499, -13.425106115034481, 0.716629844078987, 0.9109473147389415, -0.9699111632215222, 0.7330514895831962, -8.676710451522405, 0.8603313964362214, -0.276508251656302, 0.1358368365093692, -0.08183644679491195, 0.05511511638355645, 2.734556542480046, -0.14761486720414907, 0.007985372454174728, 0.013331605774468147, -0.016613056644877507, 0.015687810047736242], PolyPairBasis{ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}, 2}(ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 15.0544, [0.010182094650085734, 0.47906238685593, 0.35707264570456865, 0.3197251836505448, 0.3026070374053987, 0.293166253044118], [0.0, -6.028776107189661, -3.611667662736488, -2.918035120066678, -2.612317762801677, -2.4480596589079116], [0.0, 0.0, -0.7453572968815713, -0.8954065440091864, -0.9464598126125203, -0.9688018347417596], [0.2426345875, 0.2574537625, 0.2722729375, 0.2870921125, 0.3019112875, 0.3167304625, 0.3315496375, 0.3463688125, 0.3611879875, 0.3760071625  …  14.9136178375, 14.9284370125, 14.9432561875, 14.958075362499999, 14.9728945375, 14.9877137125, 15.0025328875, 15.017352062499999, 15.0321712375, 15.0469904125], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88), 0.0, 7.0), JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), [0 6; 6 12]))]), Dict{String, Any}(&quot;lsqr_damp&quot; =&gt; 0.01, &quot;c&quot; =&gt; [-10.989498049255403, 2.1663478824986044, -0.11867221259592667, -0.1803199617739813, -0.14068308401103413, -0.028990296492123247, 0.3705685723582922, 1.2158300262208281, 0.1932456455720456, 0.012217956259533449  …  -0.276508251656302, 0.1358368365093692, -0.08183644679491195, 0.05511511638355645, 2.734556542480046, -0.14761486720414907, 0.007985372454174728, 0.013331605774468147, -0.016613056644877507, 0.015687810047736242], &quot;dbpath&quot; =&gt; &quot;&quot;, &quot;Ibasis&quot; =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  205, 206, 207, 208, 209, 210, 211, 212, 213, 214], &quot;weights&quot; =&gt; Dict{Any, Any}(&quot;ignore&quot; =&gt; String[], &quot;default&quot; =&gt; Dict(&quot;V&quot; =&gt; 1.0, &quot;E&quot; =&gt; 1.0, &quot;F&quot; =&gt; 1.0), &quot;FLD_TiAl&quot; =&gt; Dict(&quot;V&quot; =&gt; 1.0, &quot;E&quot; =&gt; 30.0, &quot;F&quot; =&gt; 1.0), &quot;TiAl_T5000&quot; =&gt; Dict(&quot;V&quot; =&gt; 1.0, &quot;E&quot; =&gt; 5.0, &quot;F&quot; =&gt; 1.0)), &quot;lsqr_maxiter&quot; =&gt; 100000, &quot;solver&quot; =&gt; :lsqr, &quot;regularisers&quot; =&gt; Any[], &quot;lsqr_verbose&quot; =&gt; false, &quot;lsqr_atol&quot; =&gt; 1.0e-6…))</code></pre><p><code>fitted_potential</code> is the fitted potential which can be evaluated in julia and <code>lsqinfo</code> contains information about the fit. The potential will also be saved to the file <code>ACE.json</code> which can be read in python or julia. If you want to export the potential to LAMMPS, use</p><pre><code class="language-julia hljs">ACE1pack.ExportMulti.export_ACE(&quot;TiAl_tutorial_pot.yace&quot;, fitted_potential)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TiAl/">« Fitting a TiAl potential (Julia)</a><a class="docs-footer-nextpage" href="../../tutorials/lammps/">LAMMPS »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 8 September 2022 09:39">Thursday 8 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

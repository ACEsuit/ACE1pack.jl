var documenterSearchIndex = {"docs":
[{"location":"IPFitting/Solvers/#Least-squares-solvers","page":"Least squares solvers","title":"Least squares solvers","text":"","category":"section"},{"location":"IPFitting/Solvers/#:lsqr","page":"Least squares solvers","title":":lsqr","text":"","category":"section"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The :lsqr solver solves the linear system with l^2 regularisation:","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"mathbfc = textarg min_mathbfc  mathbfy - Psi mathbfc ^2 + lambda^2  mathbfc ^2","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The solver dictionary should have the following arguments:","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :lsqr,\n        \"damp\" => 5e-3,\n        \"atol\" => 1e-6)","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"where damp is lambda in the equation above. The implementation is iterative and atol is a convergence tolerance at which to stop the alogrithm.","category":"page"},{"location":"IPFitting/Solvers/#:rrqr","page":"Least squares solvers","title":":rrqr","text":"","category":"section"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :rrqr,\n        \"rrqr_tol\" => 1e-5)","category":"page"},{"location":"IPFitting/Solvers/#:brr","page":"Least squares solvers","title":":brr","text":"","category":"section"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"The :brr - Bayesian Ridge Regression - is a wrapper for scikit learn's BayseianRidge linear model see here. A Gaussian prior on the parameter vector, and a Gaussian likelihood function are used to copmute the maximum posterior probability parameter vector. Following this, the hyperparamters of the Gaussian priors are optimised by maximising the marginal log likelihood of the obsrevations. ","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver = Dict(\n        \"solver\" => :brr)","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"Since this algorithm includes hyperparameter maximisation, no parameters are required in the solver dictionary.","category":"page"},{"location":"IPFitting/Solvers/","page":"Least squares solvers","title":"Least squares solvers","text":"solver= Dict(\n         \"solver\" => :ard,\n         \"ard_tol\" => 1e-4,\n         \"threshold_lambda\" => 1e-2)","category":"page"},{"location":"IPFitting/IPFitting/#ACE1-and-IPFitting","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"ACE1.jl defines functions from the space of local atomic environments mathcalX to the space of real numbers mathbbR. These functions respect physical symmetries such as invariance under rotation of the environment and permutation of equivalent atoms. This set of functions B_nu _nu may be treated as a basis of a space of such symmetric functions, allowing us to express a property of an atomic environment R in mathcalX as follows:","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"y(R) = sum_nu c_nu B_nu(R)","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"Having explicitly constructed such a basis set, the coefficients c_nu can be found by fitting the model to data  (R_i y_i) _i and solving by, for instance, least squares:","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"mathbfc = textarg min_mathbfc sum_i left( y_i - sum_nu c_nu B_nu(R_i) right)^2 + textREG","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"ACE1.jl describes the symmetric basis set; IPFitting.jl handles the assembly and solution of the resulting least squares system, and provides a variety of methods for doing so including different regularization methods. IPFitting.jl also defines a type Dat [source] which represents a labelled atomic configuration.","category":"page"},{"location":"IPFitting/IPFitting/#The-Least-Squares-Database","page":"ACE1 and IPFitting","title":"The Least Squares Database","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"The minimisation problem above can be written:","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"mathbfc = textarg min_mathbfc  mathbfy - Psi mathbfc ^2","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"where y_i are the observations of the true function, and Psi_i nu = B_nu(R_i) is the design matrix. IPFitting constructs the design matrix and the observation vector (from the basis and training configurations) and stores them in an IPFitting.lsqDB: [source]","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"dB = LsqDB(save_name, basis, train)","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"If save_name is the empty string, the least squares system, which can be very large, is not saved to disk. Otherwise, save_name should be a string not including any file extension, which is added by IPFitting. basis is the ACE1 basis. train is a Vector of IPFitting Dat objects representing the training set. IPFitting also provides tools for reading and saving the atomic structures see File io. ","category":"page"},{"location":"IPFitting/IPFitting/#Structure-of-the-Linear-System.","page":"ACE1 and IPFitting","title":"Structure of the Linear System.","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"Observations of the energy, forces and virial stresses of an atomic configuration can be used to train a model. Each scalar observable contributes one row to the linear system: An energy observation therefore contributes a single row, and the forces on all the of the N atoms in a configuration contribute 3N rows. Training configurations can also be distinguised from one another by setting the configtype field in the IPFitting Dat object [source]. The least squares database recognises the config type of a configuration, which can be used to apply different settings for different config types when fitting.","category":"page"},{"location":"IPFitting/IPFitting/#Solving-the-Linear-System","page":"ACE1 and IPFitting","title":"Solving the Linear System","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"Fitting is performed by calling lsqfit.","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"IP, lsqinfo = lsqfit(dB, solver=solver, weights=weights, Vref=Vref, error_table=true)","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"arguments (see below for details):","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"dB : IPFitting.lsqDB. The least sqaures system to be solved.\nsolver : Dict(). Specifies the solution method.\nweights : Dict(). The weights of the different observations (rows) of the least squares system.\nVref : Dict(). A reference potential.\nerror_table : bool If true a table containing fitting errors is printed and stored in lsqinfo. ","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"returns:","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"IP : The interatomic potential that can be evaluated on a new configuration.\nlsqinfo : A dictionary of information about the least sqaures system and the solution process.","category":"page"},{"location":"IPFitting/IPFitting/#Solvers","page":"ACE1 and IPFitting","title":"Solvers","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"Once the linear system has been formed, several methods exist for solving it. Some involve modifying the above minimisation statement but still require the design matrix and observation vector. Currently there are 4{?} solvers implemented in IPFitting which are discussed in solvers.","category":"page"},{"location":"IPFitting/IPFitting/#Weights","page":"ACE1 and IPFitting","title":"Weights","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"The weights dictionary can be used to rescale rows of the linear equation to emphasise some observations more than others. For instance, it may be useful to weight the rows of the linear system corresponding to the energy larger than those corresponding to forces, if there are many more force observations than energy observations. Different weight can also be set for different config types. An example for a database containing training data with config types MD and Phonon, might be:","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"weights = Dict(\n        \"MD\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"Phonon\" => Dict(\"E\" => 10.0, \"F\" => 10.0 , \"V\" => 10.0 ))","category":"page"},{"location":"IPFitting/IPFitting/#Reference-potential","page":"ACE1 and IPFitting","title":"Reference potential","text":"","category":"section"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"It is also possible to suply a reference potential V, which acts as a baseline for the prediction. If a reference potential is supplied, the prediction is modelled as","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"y(R) = V(R) + sum_nu c_nu B_nu(R)","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"To implement this, the least squares database subtracts the reference from the observations before forming the linear system. The energy of the uninteracting isolated atoms (a OneBody potential) is good reference potential:","category":"page"},{"location":"IPFitting/IPFitting/","page":"ACE1 and IPFitting","title":"ACE1 and IPFitting","text":"Vref = OneBody(:Ti => -1586.0195, :Al => -105.5954)","category":"page"},{"location":"gettingstarted/pkg/#Using-the-Julia-Package-Manager","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This is a very brief introduction to the Julia package manager, intended for newcomers to Julia who are here primarily to use the ACEsuit. But it is not really ACE specific at all. ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The package manager provides functionality to organize reproducable Julia projects. A project is specified by a Project.toml where the user specifies which packages are required, and version bounds on those packages. The Package manager can then resolve these dependencies which results in a Manifest.toml where the full Julia environment is precisely specified. This can be used in a workflow as follows:","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"To start a new project that uses ACE1.jl, e.g. to develop a new interatomic potential for TiAl we first create a new folder where the project will live, e.g., ace1_TiAl_project. Change to that folder and start the Julia REPL. Type ] to switch to the package manager, then activate a new project in the current directory via activate .\nYou now have an empty project. Start adding the packages you need, e.g.,   add ACE1, JuLIP, IPFitting","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Type status to see your required packages listed. (Note this is only a subset of the installed packages!). Exit the REPL and type ls; you will then see a new file Project.toml which lists the project requirements, and a Manifest.toml which lists the actually packages and the version that have been installed.","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Specify version bounds: Open Project.toml in an editor and under the [compat] section you can now add version bounds, e.g. ACE1 = \"0.9, 0.10\". Please see the Pkg.jl docs for details on how to specify those bounds. Start a Julia REPL again, type ] to switch to the package manager and then up to up- or down-grade all installed packages to the latest version compatible with your bounds.","category":"page"},{"location":"gettingstarted/pkg/#Using-a-Deverlopment-Branch","page":"Using the Julia Package Manager","title":"Using a Deverlopment Branch","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"If you are a user rather than developer it should almost never be required for you to check out a package (or, dev it in the package manager). When developers make changes to - say - ACE1.jl they will always immediately tag another version and then you can adjust your version bounds in your project to update as well as enforce which version to use. However a developer would frequently do this, and occasionally it might be required when iterating between a user and developer for testing. There are multiple ways to achieve this; the following is our recommended procedure: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Suppose for example that a development branch co/dev of ACE1.jl is needed in a project project. Then one should perform the following steps: ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Make sure ACE1 has been added to project/Project.toml \nIn a separate folder, /path/to/ , clone ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"cd /path/to\ngit clone git@github.com:ACEsuit/ACE1.jl.git\ngit checkout co/dev","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"so that the repo will now live in /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Go to and activate project, then in a Julia REPL switch to the package manager ] and execute","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"dev /path/to/ACE1.jl","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"This will replace the ACE1 package in the Manifest with the version that lives in /path/to/ACE1.jl ","category":"page"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"Later on, when you want to go back to the standad Pkg versin control you can simply release ACE1.","category":"page"},{"location":"gettingstarted/pkg/#Further-Notes","page":"Using the Julia Package Manager","title":"Further Notes","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"The Project.toml should always be committed to your project git repo. Whether Manifest.toml is also committed is a matter of taste or context. Tracking the Manifest will (normally) ensure future compatibility since it allows you to reconstruct the precise Julia environemt that was used when the Manifest was created.","category":"page"},{"location":"gettingstarted/pkg/#Links","page":"Using the Julia Package Manager","title":"Links","text":"","category":"section"},{"location":"gettingstarted/pkg/","page":"Using the Julia Package Manager","title":"Using the Julia Package Manager","text":"https://pkgdocs.julialang.org/v1/\nhttps://pkgdocs.julialang.org/v1/compatibility/","category":"page"},{"location":"Using_ACE/openmm/#OpenMM","page":"OpenMM","title":"OpenMM","text":"","category":"section"},{"location":"ACE/aceintro/#Introduction-to-ACE-Models","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"","category":"section"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The purpose of this section is to give a brief summary of the mathematics behind linear ACE parameterisations of invariant atomic properties. ","category":"page"},{"location":"ACE/aceintro/#Invariant-Properties","page":"Introduction to ACE Models","title":"Invariant Properties","text":"","category":"section"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To explain the main ideas in the simplest non-trivial setting, we consider systems of indistinguishable particles. A configuration is an mset R =  bm r_j _j subset mathbbR^3 with arbitary numbers of particles and we wish to develop representation of properties ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   varphibig(R) in mathbbR","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"which are invariant under permutations (already implicit in the fact that R is an mset) and under isometries O(3). To make this explicit we can write this as","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"varphibig(  Q bm r_sigma j _j big)\n=\nvarphibig(  bm r_j _j big) qquad forall Q in O(3) \nquad sigma text a permutation","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"To that end we proceed in three steps: ","category":"page"},{"location":"ACE/aceintro/#Density-Projection-/-Atomic-Base","page":"Introduction to ACE Models","title":"Density Projection / Atomic Base","text":"","category":"section"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"We define the \"atomic density\"","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"rho(bm r) = sum_j delta(bm r - bm r_j)","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Then we choose a one-particle basis ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"phi_v(bm r) = phi_nlm(bm r) = R_n(r) Y_l^m(hatbm r)","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"and project rho` onto that basis, ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"A_v = A_nlm = langle phi_nlm rho rangle = \n   sum_j phi_nlm(bm r_j)","category":"page"},{"location":"ACE/aceintro/#Density-correlations","page":"Introduction to ACE Models","title":"Density correlations","text":"","category":"section"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Next, we form the N-correlations of the density, rho^otimes N and project them onto the tensor project basis, ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"   bm A_bm nlm \n   = Biglangle otimes_t = 1^N phi_n_t l_t m_t rho^otimes N Bigrangle \n   = prod_t = 1^N A_n_t l_t m_t","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The reason to introduce these is that in the next step, the symmetrisation step the density project would loose all angular information while the N-correlations retain most (though not all) of it. ","category":"page"},{"location":"ACE/aceintro/#Symmetrisation","page":"Introduction to ACE Models","title":"Symmetrisation","text":"","category":"section"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Finally, we symmetrize the N-correlations, by integrating over the O(3)-Haar measure, ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  B_bm nlm propto \n  int_O(3) bm A_bm nlm circ Q  dQ ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of properties of the spherical harmonics one can write this as ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"  bm B = mathcalU bm A","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"where bm A is the vector of 1, 2, ..., N correlations (the maximal N is an approximation parameter!) and mathcalU is a sparse matrix (the coupling coefficients).","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"If one symmetrised all possible N-correlations then this would create a spanning set, but one can easily reduce this to an actual basis. This construction then yields a basis of the space of symmetric polynomials. ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Notes: ","category":"page"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"Because of permutation symmetry only ordered bm v tuples are retained","category":"page"},{"location":"ACE/aceintro/#Linear-Dependence","page":"Introduction to ACE Models","title":"Linear Dependence","text":"","category":"section"},{"location":"ACE/aceintro/","page":"Introduction to ACE Models","title":"Introduction to ACE Models","text":"The construction described above introduces a lot of linear dependence which is removed in the ACE basis construction in a mixed symbolic / numerical procedure. In the end we no longer index the symmetrized basis functions as B_bm nlm but as B_bm nli with i indexing the linearly independent basis functions from the bm nl block. ","category":"page"},{"location":"tutorials/developing/#Developing-a-new-ACE1.jl-model","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"","category":"section"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Make sure to first read the installation notes. Now start by importing the required packages: ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"using ACE1, JuLIP, IPFitting\nusing LinearAlgebra: norm ","category":"page"},{"location":"tutorials/developing/#Step-1:-specify-the-ACE-basis","page":"Developing a new ACE1.jl model","title":"Step 1: specify the ACE basis","text":"","category":"section"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"The ACE basis can be set up using the function ace_basis(). ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"r0 = rnn(:Si)\nbasis = ace_basis(; \n      species = :Si,\n      N = 3,                        # correlation order = body-order - 1\n      maxdeg = 12,                  # polynomial degree\n      D = SparsePSHDegree(; wL=1.5, csp=1.0),\n      r0 = r0,                      # estimate for NN distance\n      rin = 0.65*r0, rcut = 5.0,    # domain for radial basis (cf documentation)\n      pin = 0)\n@show length(basis)","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"where the parameters have the following meaning: ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"species: chemical species, for multiple species provide a list \nN : correlation order \nmaxdeg: maximum polynomial degree \nD : specifies the notion of polynomial degree for which there is no canonical definition in the multivariate setting. Here we use SparsePSHDegree which specifies a general class of sparse basis sets; see its documentation for more details.\nr0 : an estimate on the nearest-neighbour distance for scaling, JuLIP.rnn() function returns element specific earest-neighbour distance\nrin, rcut : inner and outer cutoff radii \npin :  specifies the behaviour of the basis as the inner cutoff radius.","category":"page"},{"location":"tutorials/developing/#Step-2:-Generate-a-training-set","page":"Developing a new ACE1.jl model","title":"Step 2: Generate a training set","text":"","category":"section"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Normally one would generate a training set using DFT data, store it e.g. as  an .xzy file, which can be loaded via IPFitting. Here, we will just general  a random training set to show how it will be used. ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"function gen_dat()\n   sw = StillingerWeber() \n   n = rand(2:4)\n   at = rattle!(bulk(:Si, cubic=true) * n, 0.3)\n   return Dat(at, \"diax$n\"; E = energy(sw, at), F = forces(sw, at) )\nend\n\ntrain = [ gen_dat() for _=1:50 ]","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"gen_dat() generates a single training configuration wrapped in an IPFitting.Dat structure. Each d::Dat contains the structure d.at, and energy value and a force vector to train against. These are stored in the dictionary d.D. Other observations can also be provided. The string \"diax$n\" is a configtype label given to each structure which is useful in seeing what the performance of the model is on different classes of structures. \ntrain is then a list of 50 such training configurations.","category":"page"},{"location":"tutorials/developing/#Step-3:-Estimate-Parameters","page":"Developing a new ACE1.jl model","title":"Step 3: Estimate Parameters","text":"","category":"section"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"First we evaluate the basis on all training configurations. We do this by assembling an LsqDB which contains all information about the basis, the training data and also stores the values of the basis on the training data for later reuse e.g. to experiment with different parameter estimation algorithms, or parameters. ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"dB = LsqDB(\"\", basis, train)","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Using the empty string \"\" as the filename means that the LsqDB will not be automatically stored to disk.","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"To assemble the LSQ system we now need to specify weights. If we want to give the same energy and force weights to all configurations, we can just do the following: ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"weights = Dict(\"default\" => Dict(\"E\" => 15.0, \"F\" => 1.0 , \"V\" => 1.0 ))","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"But e.g. we could give different weights to diax2, diax3, diax4 configs. ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Now we can fit the potential using ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"IP, lsqinfo = lsqfit(dB; weights = weights, error_table = true) ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"This assembles the weighted LSQ system, and retuns the potential IP as well as a dictionary lsqinfo with some general information about the potential and fitting process.  E.g., to see the training errors we can use ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"rmse_table(lsqinfo[\"errors\"])","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Note that IP is a JuLIP.jl calculator and can be used to evaluate e.g. energy, forces, virial on new configurations. ","category":"page"},{"location":"tutorials/developing/#Step-4:-Run-some-tests","page":"Developing a new ACE1.jl model","title":"Step 4: Run some tests","text":"","category":"section"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"At a minimum we should have a test set to check generalisations, but more typically we would now run extensive robustness tests. For this mini-tutorial we will just implement a very basic energy generalisation test. ","category":"page"},{"location":"tutorials/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"test =  [ gen_dat() for _=1:20 ]\nEtest = [ dat.D[\"E\"][1] for dat in test ]\nEmodel = [ energy(IP, dat.at) for dat in test ] \nrmse_E = norm(Etest - Emodel) / sqrt(length(test))","category":"page"},{"location":"IPFitting/File IO/#File-reading-and-writing","page":"File reading and writing","title":"File reading and writing","text":"","category":"section"},{"location":"IPFitting/File IO/","page":"File reading and writing","title":"File reading and writing","text":"reading and writing of extxyz files and ACE potentials, training databases. ","category":"page"},{"location":"ACE/datatypes/#Data-types-in-the-ACE1.jl-code","page":"Data types in the ACE1.jl code","title":"Data types in the ACE1.jl code","text":"","category":"section"},{"location":"tutorials/#ACE.jl-Tutorials","page":"-","title":"ACE.jl Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"-","title":"-","text":"create list of tutorials for more interesting problems","category":"page"},{"location":"IPFitting/Manipulating potentials/#Manipulating-ACE-potentials","page":"Manipulating ACE potentials","title":"Manipulating ACE potentials","text":"","category":"section"},{"location":"IPFitting/Manipulating potentials/","page":"Manipulating ACE potentials","title":"Manipulating ACE potentials","text":"add_fits_serial\nerror tables\nRepulasive cores\nevaluation of ACE potentials in Julia","category":"page"},{"location":"tutorials/lammps/#LAMMPS-interface","page":"LAMMPS interface","title":"LAMMPS interface","text":"","category":"section"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"The ACE1 potentials can be exported as shown in the TiAl tutorial. Here we will demonstrate how this potential can be used using the LAMMPs pace pairstyle. Before using this make sure a LAMMPs executable with ML-PACE is compiled (https://github.com/lammps/lammps)","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"import os\nfrom ase.calculators.lammpsrun import LAMMPS\nfrom ase.io import read\nimport time","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"For LAMMPs in Python the ASE_LAMMPSRUN_COMMAND needs to be set pointing to a LAMMPs built using PACE.","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"os.environ[\"ASE_LAMMPSRUN_COMMAND\"]=\"~/gits/lammps/build/lmp\"","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"Setting up the LAMMPs calculator using traditional LAMMPs commands.","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"parameters = {'pair_style': 'pace',\n             'pair_coeff': ['* * TiAl_tutorial_pot.yace Ti Al']}\n\nfiles = [\"TiAl_tutorial_pot.yace\"]\n\ncalc1 = LAMMPS(parameters=parameters, files=files)","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"Using the LAMMPS calculator to evaluate energies/forces/virials from Python","category":"page"},{"location":"tutorials/lammps/","page":"LAMMPS interface","title":"LAMMPS interface","text":"at = read(\"./TiAl_tutorial_DB.xyz\", \":\")[0]\n\nat.set_calculator(calc1)\n\nprint(at.get_potential_energy())\nprint(at.get_forces())\nprint(at.get_stress())","category":"page"},{"location":"tutorials/createsavefit/#TiAl-Tutorial","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"","category":"section"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Make sure to set the environment variable JULIA_NUM_THREADS to enable threading in the least squares assembly LsqDB(). Also, BRR/ARD solvers will see increased performance if you enable Python numpy threading (most likely MKL_NUM_THREADS, can be confirmed by checking ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"import numpy; numpy.show_config()","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"in Python.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"For fitting interatomic potentials using Julia the packages ACE1 and IPFitting are required.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"using ACE1\nusing IPFitting","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Reading in the .xyz containing the TiAl configurations. energy_key, force_key and virial_key need to specified in order to make sure correct data is read. Slicing is done here to reduce fitting time such that it is feasible on a laptop. ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"al = IPFitting.Data.read_xyz(@__DIR__() * \"/TiAl_tutorial_DB.xyz\", energy_key=\"energy\", force_key=\"force\", virial_key=\"virial\")[1:10:end];","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Next typical interatomic distance between the atoms r0 is defined. Nearest neighbour distances of Ti and Al are quite similar (rnn(:Ti)=2.89607, rnn(:Al)=2.86378) so here we just take the average. For atomistic systems with large differences in neighour distances (or \"size\" of atoms) it is advised to use MultiTransforms() as defined in Tutorial ? per element pair.  ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"r0 = 0.5*(rnn(:Ti) + rnn(:Al))","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"The rotational and permutation invariant ACE basis, ace_basis is defined as follows. Here N is the correlation order, r0 the previously defined typical nearest neighbour distance, rin the inner cutoff, rcut the outer cutoff and maxdeg the maximum polynomial degree of the ACE basis.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"ACE_basis = ace_basis(species = [:Ti, :Al],\n                              N = 3,\n                              r0 = r0,\n                              rin = 0.6 * r0,\n                              rcut = 5.5,\n                              maxdeg = 6)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"A simple pair-potential is defined below where pin=0 means no inner cutoff, and pcut=1","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"2B_basis = pair_basis(species = [:Ti, :Al],\n      r0 = r0,\n      maxdeg = 6,\n      rcut = 7.0,\n      pcut = 1,\n      pin = 0)  ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"A IPSuperBasis is created by combining the pair-potential and the ACE basis. The pair-potential ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"B = JuLIP.MLIPs.IPSuperBasis([Bpair, ACE_B]);","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Using the combined basis and the configurations a least squares database is created. When \"\" is specified the database is not saved to disk. If a filename fname is specified the least squares can be read in using LsqDB(\"fname\") ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"dB = LsqDB(\"\", B, al)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"A reference potential containing the isolated energies is defined using OneBody(). These energies will be subtracted from the total energy observations when fitting.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Vref = OneBody(:Ti => -1586.0195, :Al => -105.5954)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Weights are required per energy/force/virial observations and can be specified per configuration type. ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"weights = Dict(\n        \"default\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"FLD_TiAl\" => Dict(\"E\" => 5.0, \"F\" => 1.0 , \"V\" => 1.0 ),\n        \"TiAl_T5000\" => Dict(\"E\" => 30.0, \"F\" => 1.0 , \"V\" => 1.0 ))","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Next a solver dictionary is created specifying the regularising method and its parameters.","category":"page"},{"location":"tutorials/createsavefit/#LSQR","page":"TiAl Tutorial","title":"LSQR","text":"","category":"section"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"solver = Dict(\n        \"solver\" => :lsqr,\n        \"lsqr_damp\" => 5e-3,\n        \"lsqr_atol\" => 1e-6)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Iterative solver where lsqr_damp is the L2 penalty and lsqr_atol the convergence parameter.","category":"page"},{"location":"tutorials/createsavefit/#RRQR","page":"TiAl Tutorial","title":"RRQR","text":"","category":"section"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"solver = Dict(\n        \"solver\" => :rrqr,\n        \"rrqr_tol\" => 1e-5)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Rank-revealing QR factorisation determines a low rank solution to the linear system. Smaller \"rrqr_tol\" means less regularisation. ","category":"page"},{"location":"tutorials/createsavefit/#Bayesian-Ridge-Regression-(BRR)","page":"TiAl Tutorial","title":"Bayesian Ridge Regression (BRR)","text":"","category":"section"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"solver = Dict(\n        \"solver\" => :brr,\n        \"brr_tol\" => 1e-3)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Bayesian Ridge Regression performing evidence maximisation. brr_tol sets the convergence for the marginal log likelihood convergence, default is1e-3. ","category":"page"},{"location":"tutorials/createsavefit/#Automatic-Relevance-Determination-(ARD)","page":"TiAl Tutorial","title":"Automatic Relevance Determination (ARD)","text":"","category":"section"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"solver= Dict(\n         \"solver\" => :ard,\n         \"ard_tol\" => 1e-3,\n         \"ard_threshold_lambda\" => 10000)","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Automatic Relevance Determination performing evidence maximisation. ard_tol sets the convergence for the marginal log likelihood convergence, default is1e-3. ard_threshold_lambda is the threshold for removing the basis functions with low relevance, default is 10000.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Laplacian preconditioning can be used to penalise highly oscillatory basis function. This is done by creating the P matrix below and adding it to the solver dictionary.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"using LinearAlgebra\nrlap_scal = 3.0\nP = Diagonal(vcat(ACE1.scaling.(dB.basis.BB, rlap_scal)...))\nsolver[\"P\"] = P","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Fitting is done using the lsqfit command, taking the least squares database dB, weights, reference potential and solver. Specifying error_table=true calculated the errors on the training database. The lsqinfo contains a wide range of properties of the potential, such as weights, solver and parameter information. ","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"IP, lsqinfo = lsqfit(dB, solver=solver, weights=weights, Vref=Vref, error_table = true);","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Print the table containing the training database errors","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"rmse_table(lsqinfo[\"errors\"])","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Saving the potential is done as follows.","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"save_dict(\"./TiAl_tutorial_pot.json\", Dict(\"IP\" => write_dict(IP), \"info\" => lsqinfo))","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"Exporting to LAMMPs format (using the PACE calculator).","category":"page"},{"location":"tutorials/createsavefit/","page":"TiAl Tutorial","title":"TiAl Tutorial","text":"ACE1.ExportMulti.export_ACE(\"./TiAl_tutorial_pot.yace\", IP)","category":"page"},{"location":"gettingstarted/installation/#Installation-Instructions","page":"Installation Instructions","title":"Installation Instructions","text":"","category":"section"},{"location":"gettingstarted/installation/#Short-Version","page":"Installation Instructions","title":"Short Version","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"From the Julia REPL, run: ","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"using Pkg; Pkg.activate(\".\"); pkg\"registry add https://github.com/JuliaRegistries/General\"; pkg\"registry add https://github.com/JuliaMolSim/MolSim.git\"; pkg\"add ACE1pack\"","category":"page"},{"location":"gettingstarted/installation/#Detailed-Instructions","page":"Installation Instructions","title":"Detailed Instructions","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"If you have any difficulties with the following setup process, please file an issue. We highly recommend familiarizing oneself with the Julia package manager and how Project management is best done in Julia (there is also a summary in this section of these docs). In particular all projects should manage their own Project.toml file with appropriate version bounds, and where appropriate the Manifest.toml file can be tracked in order to guarantee reproducibility of results.","category":"page"},{"location":"gettingstarted/installation/#Installing-Julia","page":"Installation Instructions","title":"Installing Julia","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Download and unpack Julia. We recommend v1.6 or upwards. Add the julia executable to your path with something like export PATH=<julia-directory>/bin:$PATH.","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Start the Julia REPL (type julia followed by Enter), switch to package manager by typing ], then install the General registry and the MolSim registry:","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"registry add https://github.com/JuliaRegistries/General\nregistry add https://github.com/JuliaMolSim/MolSim.git","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Press Backspace or Ctrl-c to exit the package manager. Use Ctrl-d, or exit() followed by Enter, to close the Julia REPL.","category":"page"},{"location":"gettingstarted/installation/#Setting-up-a-new-ACE1.jl-project","page":"Installation Instructions","title":"Setting up a new ACE1.jl project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Create a folder for your new project and change to it. Start the Julia REPL and activate a new project by switching to the package manager with ], and then running","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"activate .","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"Now you can install ACE1pack. Remaining in the package manager, use","category":"page"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"add ACE1pack","category":"page"},{"location":"gettingstarted/installation/#Returning-to-a-project","page":"Installation Instructions","title":"Returning to a project","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"When returning to a project, there are several methods for reactivating it. One is to simply activate . in the package manager, as above. Alternatively set the JULIA_PROJECT environment variable to the directory with Project.toml before starting julia, or call julia as julia --project=<dir>. Special syntax like JULIA_PROJECT=@. or julia --project=@. searches the current directory and its parents for a Project.toml file.","category":"page"},{"location":"gettingstarted/installation/#Trouble-shooting","page":"Installation Instructions","title":"Trouble-shooting","text":"","category":"section"},{"location":"gettingstarted/installation/","page":"Installation Instructions","title":"Installation Instructions","text":"On some systems ASE.jl (a dependency of IPFitting.jl) is unable to automatically install python dependencies. We found that installing Anaconda and then pointing PyCall.jl to the Anaconda installation (cf PyCall Readme) resolves this. After installing Anaconda, it should then be sufficient to build ASE.jl again.\nIf you cannot use Anaconda python, or if the last point failed, then you can try to install the python dependencies manually before trying to build ASE.jl again. Specifically, it should be sufficient to just install the ase package. Please follow the installation instructions on their website.","category":"page"},{"location":"Using_ACE/lammps/#LAMMPS","page":"LAMMPS","title":"LAMMPS","text":"","category":"section"},{"location":"Using_ACE/python_ase/#Python-ASE","page":"Python ASE","title":"Python ASE","text":"","category":"section"},{"location":"gettingstarted/developing/#Developing-a-new-ACE1.jl-model","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"","category":"section"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Make sure to first read the installation notes. Now start by importing the required packages: ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"using ACE1, JuLIP, IPFitting\nusing LinearAlgebra: norm ","category":"page"},{"location":"gettingstarted/developing/#Step-1:-specify-the-ACE-basis","page":"Developing a new ACE1.jl model","title":"Step 1: specify the ACE basis","text":"","category":"section"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"The ACE basis can be set up using the function ace_basis(). ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"r0 = rnn(:Si)\nbasis = ace_basis(; \n      species = :Si,\n      N = 3,                        # correlation order = body-order - 1\n      maxdeg = 12,                  # polynomial degree\n      D = SparsePSHDegree(; wL=1.5, csp=1.0),\n      r0 = r0,                      # estimate for NN distance\n      rin = 0.65*r0, rcut = 5.0,    # domain for radial basis (cf documentation)\n      pin = 0)\n@show length(basis)","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"where the parameters have the following meaning: ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"species: chemical species, for multiple species provide a list \nN : correlation order \nmaxdeg: maximum polynomial degree \nD : specifies the notion of polynomial degree for which there is no canonical definition in the multivariate setting. Here we use SparsePSHDegree which specifies a general class of sparse basis sets; see its documentation for more details.\nr0 : an estimate on the nearest-neighbour distance for scaling, JuLIP.rnn() function returns element specific earest-neighbour distance\nrin, rcut : inner and outer cutoff radii \npin :  specifies the behaviour of the basis as the inner cutoff radius.","category":"page"},{"location":"gettingstarted/developing/#Step-2:-Generate-a-training-set","page":"Developing a new ACE1.jl model","title":"Step 2: Generate a training set","text":"","category":"section"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Normally one would generate a training set using DFT data, store it e.g. as  an .xzy file, which can be loaded via IPFitting. Here, we will just general  a random training set to show how it will be used. ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"function gen_dat()\n   sw = StillingerWeber() \n   n = rand(2:4)\n   at = rattle!(bulk(:Si, cubic=true) * n, 0.3)\n   return Dat(at, \"diax$n\"; E = energy(sw, at), F = forces(sw, at) )\nend\n\ntrain = [ gen_dat() for _=1:50 ]","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"gen_dat() generates a single training configuration wrapped in an IPFitting.Dat structure. Each d::Dat contains the structure d.at, and energy value and a force vector to train against. These are stored in the dictionary d.D. Other observations can also be provided. The string \"diax$n\" is a configtype label given to each structure which is useful in seeing what the performance of the model is on different classes of structures. \ntrain is then a list of 50 such training configurations.","category":"page"},{"location":"gettingstarted/developing/#Step-3:-Estimate-Parameters","page":"Developing a new ACE1.jl model","title":"Step 3: Estimate Parameters","text":"","category":"section"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"First we evaluate the basis on all training configurations. We do this by assembling an LsqDB which contains all information about the basis, the training data and also stores the values of the basis on the training data for later reuse e.g. to experiment with different parameter estimation algorithms, or parameters. ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"dB = LsqDB(\"\", basis, train)","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Using the empty string \"\" as the filename means that the LsqDB will not be automatically stored to disk.","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"To assemble the LSQ system we now need to specify weights. If we want to give the same energy and force weights to all configurations, we can just do the following: ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"weights = Dict(\"default\" => Dict(\"E\" => 15.0, \"F\" => 1.0 , \"V\" => 1.0 ))","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"But e.g. we could give different weights to diax2, diax3, diax4 configs. ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Now we can fit the potential using ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"IP, lsqinfo = lsqfit(dB; weights = weights, error_table = true) ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"This assembles the weighted LSQ system, and retuns the potential IP as well as a dictionary lsqinfo with some general information about the potential and fitting process.  E.g., to see the training errors we can use ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"rmse_table(lsqinfo[\"errors\"])","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"Note that IP is a JuLIP.jl calculator and can be used to evaluate e.g. energy, forces, virial on new configurations. ","category":"page"},{"location":"gettingstarted/developing/#Step-4:-Run-some-tests","page":"Developing a new ACE1.jl model","title":"Step 4: Run some tests","text":"","category":"section"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"At a minimum we should have a test set to check generalisations, but more typically we would now run extensive robustness tests. For this mini-tutorial we will just implement a very basic energy generalisation test. ","category":"page"},{"location":"gettingstarted/developing/","page":"Developing a new ACE1.jl model","title":"Developing a new ACE1.jl model","text":"test =  [ gen_dat() for _=1:20 ]\nEtest = [ dat.D[\"E\"][1] for dat in test ]\nEmodel = [ energy(IP, dat.at) for dat in test ] \nrmse_E = norm(Etest - Emodel) / sqrt(length(test))","category":"page"},{"location":"IPFitting/Atomic Configurations in Julia/#Atomic-configurations-in-Julia","page":"Atomic configurations in Julia","title":"Atomic configurations in Julia","text":"","category":"section"},{"location":"IPFitting/Atomic Configurations in Julia/","page":"Atomic configurations in Julia","title":"Atomic configurations in Julia","text":"manipulating Atoms objects in Julia\nUnits used in ACE (eV, A)","category":"page"},{"location":"ACE/create_ACE/#Building-an-ACE-basis","page":"Building an ACE basis","title":"Building an ACE basis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ACE1pack","category":"page"},{"location":"#ACE1-and-ACE1pack-User-Documentation","page":"Home","title":"ACE1 and ACE1pack User Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACE1 is a Julia package for parameterising interatomic potentials in terms of the atomic cluster expansion, i.e., body-ordered invariant polynomials. These pages contain a user-oriented documentation. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Overview-of-Relevant-Julia-Packages","page":"Home","title":"Overview of Relevant Julia Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Usage of ACE1.jl or ACE1pack.jl involves the following Julia packages which we summarize for the same","category":"page"},{"location":"","page":"Home","title":"Home","text":"ACE1.jl specifies the parameterisation of interatomic potentials in terms of the (linear) atomic cluster expansion; it provides functions to generate invariant basis sets, and to evaluate the resulting interatomic potentials.\nIPFitting.jl supplied the functionality for parameter estimation. It focuses purely on linear models and linear observations, but provides various tools to deal with the typical data to which interatomic potentials are fitted (total energies, forces, virials, etc) and the reading and transforming of training data. A broad range of solvers are available through this package. \nJuLIP.jl is a simple molecular simulation code in pure Julia, focusing primarily on an infrastructure to develop interatomic potentials. It provides various generic functions on top of which all our packages on this page build.\nACE1pack.jl has two purposes: (1) import and re-export ACE1.jl, IPFitting.jl, JuLIP.jl with guaranteed version compatibility; and (2) several convenience wrappers for ACE1.jl and IPFitting.jl\nACEinterfaces.jl provides interfaces to use ACE potentials from other languages; experimental  ","category":"page"},{"location":"#Key-references","page":"Home","title":"Key references","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). [DOI] [arxiv]\nG. Dusson, M. Bachmayr, G. Csanyi, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Completeness, efficiency and stability. J. Comp. Phys. 454, 110946, 2022. [DOI] [arxiv]","category":"page"}]
}

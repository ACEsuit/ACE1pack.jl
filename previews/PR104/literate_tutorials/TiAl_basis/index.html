<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fitting a TiAl potential (Julia) - acebasis · ACE1pack.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://ACEsuit.github.io/ACE1pack.jl/literate_tutorials/TiAl_basis/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ACE1pack.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../gettingstarted/installation/">Installation Instructions</a></li><li><a class="tocitem" href="../../gettingstarted/pkg/">Using the Julia Package Manager</a></li><li><a class="tocitem" href="../../gettingstarted/aceintro/">Introduction to ACE Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Tutorials Overview</a></li><li><a class="tocitem" href="../../tutorials/first_example_json/">TiAl potential (command line JSON)</a></li><li><a class="tocitem" href="../first_example_basis/">First example (Julia) - <code>acebasis</code></a></li><li><a class="tocitem" href="../first_example_model/">First example (Julia) - <code>acemodel</code></a></li><li class="is-active"><a class="tocitem" href>Fitting a TiAl potential (Julia) - <code>acebasis</code></a></li><li><a class="tocitem" href="../TiAl_model/">Fitting a TiAl potential (Julia) - <code>acemodel</code></a></li><li><a class="tocitem" href="../ACE1pack_TiAl/">TiAl potential (ACE1pack-julia)</a></li><li><a class="tocitem" href="../descriptor/">ACE Descriptors</a></li><li><a class="tocitem" href="../committee/">Committee Potentials</a></li><li><a class="tocitem" href="../../tutorials/lammps/">LAMMPS</a></li><li><a class="tocitem" href="../../tutorials/python_ase/">python-<code>ase</code></a></li></ul></li><li><span class="tocitem">Command line</span><ul><li><a class="tocitem" href="../../command_line/">Command line interface</a></li></ul></li><li><span class="tocitem">ACE1pack Internals</span><ul><li><a class="tocitem" href="../../ACE1pack/ace1pack_overview/">Overview</a></li><li><a class="tocitem" href="../../ACE1pack/fit/">Fitting ACE</a></li><li><a class="tocitem" href="../../ACE1pack/helpers/">Helper Functions</a></li><li><a class="tocitem" href="../../ACE1pack/data/">Handling Data</a></li><li><a class="tocitem" href="../../ACE1pack/basis/">Constructing Basis</a></li><li><a class="tocitem" href="../../ACE1pack/solver/">Solvers</a></li><li><a class="tocitem" href="../../ACE1pack/all_exported/">All ACE1pack functions</a></li></ul></li><li><span class="tocitem">ACEfit Internals</span><ul><li><a class="tocitem" href="../../ACEfit/Fitting/">ACE1 and ACEfit</a></li><li><a class="tocitem" href="../../ACEfit/Solvers/">Least squares solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Fitting a TiAl potential (Julia) - <code>acebasis</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fitting a TiAl potential (Julia) - <code>acebasis</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ACEsuit/ACE1pack.jl/blob/main/tutorials/TiAl_basis.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fitting-a-TiAl-potential-(Julia)-acebasis"><a class="docs-heading-anchor" href="#Fitting-a-TiAl-potential-(Julia)-acebasis">Fitting a TiAl potential (Julia) - <code>acebasis</code></a><a id="Fitting-a-TiAl-potential-(Julia)-acebasis-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-a-TiAl-potential-(Julia)-acebasis" title="Permalink"></a></h1><p>Start by importing the required libraries</p><pre><code class="language-julia hljs">using ACE1pack</code></pre><p>We need a dataset <code>TiAl_tutorial.xyz</code> for this tutorial which is provided as an artifact. Normally we would get the path to a datset via <code>artifact&quot;TiAl_tutorial</code> but for these tutorial to run from anywhere it is easiest to let <code>ACE1pack</code> load the data for us. The following line will download the dataset, store is somewhere inside <code>~/.julia/...</code> and return a string with the absolute path to the file.</p><pre><code class="language-julia hljs">data_file = joinpath(ACE1pack.artifact(&quot;TiAl_tutorial&quot;), &quot;TiAl_tutorial.xyz&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/.julia/artifacts/b437d7d5fac4424b8203d0afc31732879d3da5b2/TiAl_tutorial.xyz&quot;</code></pre><p>We can now use <code>JuLIP.read_extxyz</code> to load in the training set. We keep only a small subset of the training structures to keep the regression problem small.</p><pre><code class="language-julia hljs">data = JuLIP.read_extxyz(data_file)
train_data = data[1:5:end];</code></pre><p>The next step is to generate a basis set:</p><ul><li><code>N = 3</code> : We take 3-correlation, i.e. a 4-body potential,</li><li><code>maxdeg = 6</code> : a very low polynomial degree just for testing</li><li><code>rcut = 5.5</code> : this is a typical cutoff radius</li></ul><p>These three are the most important approximation parameters to explore when trying to improve the fit-accuracy. In addition there is</p><ul><li>The parameter <code>r0</code> is just a scaling parameter and the fits should not be very sensitive to its choice. A rough estimate for the nearest-neighbour distance is usually ok. (NB: if you change to a non-trivial distance transform, then the parameter <code>r0</code> may become important.)</li><li>The inner cutoff <code>rin</code> with <code>pin = 2</code> results in an envelope for the radial basis that becomes zero when atoms get too close. The reason for this is that we usually do not have data against which to fit the potential in this deformation regime and therefore cannot make reliable predictions. Instead we will add a pair potential to model this regime below.</li></ul><pre><code class="language-julia hljs">r0 = 2.88
ACE_B = ace_basis(species = [:Ti, :Al],
                  N = 3,
                  maxdeg = 6,
                  rcut = 5.5,
                  r0 = r0,
                  rin = 0.6 * r0, pin = 2);</code></pre><p>As alluded to above, we now add a pair potential to obtain qualitatively correct repulsive behaviour for colliding atoms. The many-body basis <code>ACE_B</code> and the pair potential <code>Bpair</code> are then combined into a single basis set <code>B</code>.</p><pre><code class="language-julia hljs">Bpair = pair_basis(species = [:Ti, :Al],
                   r0 = r0,
                   maxdeg = 6,
                   rcut = 7.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PolyPairBasis{ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}, 2}(JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}[ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope()) ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope()); ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope()) ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope())], [0 6; 6 12])</code></pre><p>We combine the two bases into a superbasis.</p><pre><code class="language-julia hljs">B = JuLIP.MLIPs.IPSuperBasis([Bpair, ACE_B]);</code></pre><p><code>Vref</code> specifies a reference potential, which is subtracted from the training data and the ACE parameters are then estimated from the difference. This reference potential will in the end be added to the ACE model. Here we use a one-body potential i.e. a reference atom energy for each individual species. Usage of a one-body reference potential generally results in very slightly reduced fit accuracy but significantly improved 2-body potentials with a realistic dimer shape.</p><pre><code class="language-julia hljs">Vref = OneBody(:Ti =&gt; -1586.0195, :Al =&gt; -105.5954)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OneBody{Float64}(Dict(:Al =&gt; -105.5954, :Ti =&gt; -1586.0195))</code></pre><p>The next line specifies the regression weights: in the least squares loss different observations are given different weights,</p><p class="math-container">\[  \sum_{R} \Big( w_^E_R | E(R) - y_R^E |^2
           + w_F^R | {\rm forces}(R) - y_R^F |^2
           + w_V^R | {\rm virial}(R) - y_R^V |^2 \Big),\]</p><p>and this is specificed via the following dictionary. The keys correspond to the <code>config_type</code> of the training structures.</p><pre><code class="language-julia hljs">weights = Dict(
        &quot;FLD_TiAl&quot; =&gt; Dict(&quot;E&quot; =&gt; 60.0, &quot;F&quot; =&gt; 1.0 , &quot;V&quot; =&gt; 1.0 ),
        &quot;TiAl_T5000&quot; =&gt; Dict(&quot;E&quot; =&gt; 5.0, &quot;F&quot; =&gt; 1.0 , &quot;V&quot; =&gt; 1.0 ))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Dict{String, Float64}} with 2 entries:
  &quot;FLD_TiAl&quot;   =&gt; Dict(&quot;V&quot;=&gt;1.0, &quot;E&quot;=&gt;60.0, &quot;F&quot;=&gt;1.0)
  &quot;TiAl_T5000&quot; =&gt; Dict(&quot;V&quot;=&gt;1.0, &quot;E&quot;=&gt;5.0, &quot;F&quot;=&gt;1.0)</code></pre><p>The next step is to evaluate the basis on the training set. Precomputing the basis once (and possibly save it to disk) makes experimenting with different regression parameters much more efficient. This is demonstrated below by showing various different solver options. Similarly once could also explore different data weights (see <code>weights</code> below).</p><pre><code class="language-julia hljs">train = [ACE1pack.AtomsData(t,&quot;energy&quot;,&quot;force&quot;,&quot;virial&quot;,weights,Vref) for t in train_data]
A, Y, W = ACEfit.linear_assemble(train, B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([1.0936179166921034 -4.105557368487966 … -25.16986836711652 -72.21930809391708; 0.0 0.0 … 0.0 0.0; … ; -0.9977531429069066 16.59236775478488 … 421.75551132386727 289.2109506633689; -0.34139435799134144 -1.7326392574607106 … 139.42436086630616 857.2242698756836], [-12.025738219999994, 0.86219, 0.78737, 2.65969, -0.86219, -0.78737, -2.65969, 5.072173561696366, 4.667636799854875, 4.700422750506493  …  0.26749, 0.6188, 0.89211, -0.83592, 190.81167395404137, 126.25441742969696, 180.37930838473264, -5.923303645968714, 7.396178147788381, -5.358153817858219], [42.426406871192846, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.7071067811865475, 0.7071067811865475, 0.7071067811865475  …  1.0, 1.0, 1.0, 1.0, 0.08838834764831843, 0.08838834764831843, 0.08838834764831843, 0.08838834764831843, 0.08838834764831843, 0.08838834764831843])</code></pre><p>We are finally coming to the parameter estimation. In this tutorial we provide four different algorithms to solve the LLSQ problem: a Krylov method LSQR, rank-revealing QR, <code>scikit-learn</code> BRR solver as well as <code>the scikit-learn</code> ARD solver.</p><pre><code class="language-julia hljs">solver_type = :lsqr
smoothness_prior = true

if solver_type == :lsqr
	solver = Dict(
        	&quot;type&quot; =&gt; &quot;LSQR&quot;,
        	&quot;damp&quot; =&gt; 1e-2,
        	&quot;atol&quot; =&gt; 1e-6)
elseif solver_type == :rrqr
	solver = Dict(
        	&quot;type&quot; =&gt; &quot;RRQR&quot;,
        	&quot;tol&quot; =&gt; 1e-5)
elseif solver_type == :brr
	solver = Dict(
        	&quot;type&quot; =&gt; &quot;BRR&quot;,
		&quot;tol&quot; =&gt; 1e-3)
elseif solver_type == :ard
	solver= Dict(
         	&quot;type&quot; =&gt; &quot;ARD&quot;,
         	&quot;tol&quot; =&gt; 1e-3,
         	&quot;threshold_lambda&quot; =&gt; 10000)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 3 entries:
  &quot;atol&quot; =&gt; 1.0e-6
  &quot;damp&quot; =&gt; 0.01
  &quot;type&quot; =&gt; &quot;LSQR&quot;</code></pre><p>ACE1.jl has a heuristic smoothness prior built in which assigns to each basis function <code>Bi</code> a scaling parameter <code>si</code> that estimates how &quot;rough&quot; that basis function is. The following line generates a regularizer (prior) with <code>si^q</code> on the diagonal, thus penalizing rougher basis functions and enforcing a smoother fitted potential.</p><pre><code class="language-julia hljs">if smoothness_prior
    using LinearAlgebra
    q = 3.0
    solver[&quot;P&quot;] = Diagonal(vcat(ACE1.scaling.(B.BB, q)...))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">214×214 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 1.0   ⋅     ⋅     ⋅      ⋅      ⋅    ⋅   …    ⋅        ⋅        ⋅     ⋅ 
  ⋅   8.0    ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅   27.0    ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅   64.0     ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅   125.0     ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅   216.0   ⋅   …    ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅   1.0       ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
 ⋮                              ⋮         ⋱   ⋮                      
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅   …    ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅   …  12.1381    ⋅        ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅      24.0416    ⋅     ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅      36.0    ⋅ 
  ⋅    ⋅     ⋅     ⋅      ⋅      ⋅    ⋅        ⋅        ⋅        ⋅   58.7878</code></pre><p>Once all the solver parameters have been determined, we use <code>ACEfit</code> to estimate the parameters. This routine will return the fitted interatomic potential <code>IP</code> as well as the a dictionary <code>lsqfit</code> with some information about the fitting process.</p><pre><code class="language-julia hljs">solver = ACEfit.create_solver(solver)
results = ACEfit.linear_solve(solver, A, Y)
potential = JuLIP.MLIPs.SumIP(Vref, JuLIP.MLIPs.combine(B, results[&quot;C&quot;]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JuLIP.MLIPs.SumIP{Any}(Any[OneBody{Float64}(Dict(:Al =&gt; -105.5954, :Ti =&gt; -1586.0195)), PolyPairPot{Float64, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}, 2, 0}([3.9844975765954898, 1.5680511663342556, -0.7505487239679074, 0.10273911925916188, -0.07969719636770435, -0.22316105737944741, -0.0348429264398887, 0.30003588424134153, -0.6108774878447673, 0.22487888109263052, 0.5585256662680345, 0.21412290434544087, 0.43068973811571004, -0.131323009951437, -0.734350515676229, -0.03717866383837841, 0.6027601850992468, 0.3766720001852793], PolyPairBasis{ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}, 2}(JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}[ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope()) ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope()); ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope()) ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.235225, 0, 2.528621338349906, [0.4251350911008923, 3.0955440313660145, 2.3072863315968486, 2.0659592802147704, 1.9553474332171712, 1.8943441808583827], [0.0, -6.644238002019547, -4.070406677000498, -3.328793035430999, -3.0010836224064996, -2.824696736978022], [0.0, 0.0, -0.745357296881563, -0.8954065440091932, -0.9464598126125161, -0.9688018347417634], [0.23637169816917494, 0.23866509450752485, 0.24095849084587476, 0.24325188718422466, 0.24554528352257457, 0.24783867986092448, 0.25013207619927436, 0.25242547253762426, 0.25471886887597417, 0.2570122652143241  …  2.506834073135582, 2.509127469473932, 2.511420865812282, 2.513714262150632, 2.5160076584889817, 2.5183010548273317, 2.5205944511656817, 2.5228878475040317, 2.5251812438423813, 2.5274746401807313], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.44, 7.0, ACE1.OrthPolys.OneEnvelope())], [0 6; 6 12]), nothing), PIPotential{Float64, 2, PIBasis{BasicPSH1pBasis{Float64, 2, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}}, 2, ACE1.DAGEvaluator}, ACE1.DAGEvaluator, 0}(PIBasis{BasicPSH1pBasis{Float64, 2, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}}, 2, ACE1.DAGEvaluator}(BasicPSH1pBasis{Float64, 2, ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}}(ACE1.OrthPolys.TransformedPolys{Float64, PolyTransform{Int64, Float64}, ACE1.OrthPolys.OrthPolyBasis{Float64}, ACE1.OrthPolys.OneEnvelope}(ACE1.OrthPolys.OrthPolyBasis{Float64}(2, 0.3563171597633136, 2, 2.022901419836431, [3.253577614437167, 3.980146542617523, 3.208896730258186, 2.9171788456892846, 2.7660000991755456, 2.675144850592528], [0.0, -4.73481930186265, -3.8173333603235693, -3.470303054839645, -3.2904594135665928, -3.1823771658251663], [0.0, 0.0, -0.8062257748298494, -0.9090909090909298, -0.948176387355483, -0.967152839723303], [0.35715045189335015, 0.35881703615342325, 0.3604836204134964, 0.3621502046735695, 0.3638167889336426, 0.3654833731937157, 0.36714995745378887, 0.36881654171386197, 0.37048312597393507, 0.3721497102340082  …  2.007068869365736, 2.0087354536258095, 2.0104020378858825, 2.012068622145956, 2.0137352064060288, 2.0154017906661017, 2.017068374926175, 2.018734959186248, 2.0204015434463214, 2.0220681277063943], [0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001  …  0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001]), PolyTransform{Int64, Float64}(2, 2.88, 1.0), 1.728, 5.5, ACE1.OrthPolys.OneEnvelope()), ACE1.SphericalHarmonics.SHBasis{Float64}(3, ACE1.SphericalHarmonics.ALPCoefficients{Float64}([0.0, 0.0, 0.0, 1.9364916731037085, 0.0, 0.0, 1.9720265943665387, 2.091650066335189, 0.0, 0.0], [0.0, 0.0, 0.0, -0.5773502691896257, 0.0, 0.0, -0.5163977794943222, -0.4472135954999579, 0.0, 0.0])), JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), ACE1.RPI.PSH1pBasisFcn[znlm[0|1,0,0], znlm[0|1,1,-1], znlm[0|1,1,0], znlm[0|1,1,1], znlm[0|1,2,-2], znlm[0|1,2,-1], znlm[0|1,2,0], znlm[0|1,2,1], znlm[0|1,2,2], znlm[0|1,3,-3]  …  znlm[0|3,2,-1], znlm[0|3,2,0], znlm[0|3,2,1], znlm[0|3,2,2], znlm[0|4,0,0], znlm[0|4,1,-1], znlm[0|4,1,0], znlm[0|4,1,1], znlm[0|5,0,0], znlm[0|6,0,0]], UnitRange{Int64}[1:40 1:40; 41:80 41:80]), JuLIP.Potentials.SZList{2}(AtomicNumber[&lt;13&gt;, &lt;22&gt;]), (ACE1.InnerPIBasis([1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [1 0 0; 17 0 0; … ; 41 57 66; 57 57 57], Dict{ACE1.PIBasisFcn, Int64}(ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|2,0,0], znlm[13|2,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 118, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[13|1,0,0], znlm[13|3,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 80, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|3,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 55, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[22|1,0,0], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 101, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[13|2,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 96, ACE1.PIBasisFcn{1, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|4,0,0],), ACE1.RPI.PSH1pBasisFcn) =&gt; 4, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[22|2,0,0], znlm[22|3,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 109, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[22|1,0,0], znlm[22|3,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 64, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[22|1,0,0], znlm[22|5,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 66, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;13&gt;, (znlm[13|1,0,0], znlm[13|1,0,0], znlm[13|1,2,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 78…), Dict{Any, Int64}(znlm[13|1,3,2] =&gt; 15, znlm[13|1,1,0] =&gt; 3, znlm[13|3,0,0] =&gt; 26, znlm[13|4,1,0] =&gt; 37, znlm[13|1,2,0] =&gt; 7, znlm[22|5,0,0] =&gt; 79, znlm[13|2,0,0] =&gt; 17, znlm[13|4,1,-1] =&gt; 36, znlm[22|1,2,0] =&gt; 47, znlm[13|2,2,2] =&gt; 25…), 1:136, &lt;13&gt;, ACE1.DAG.CorrEvalGraph{Int64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0  …  127, 128, 129, 130, 131, 132, 133, 134, 135, 136], 80, 104)), ACE1.InnerPIBasis([1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [1 0 0; 17 0 0; … ; 41 57 66; 57 57 57], Dict{ACE1.PIBasisFcn, Int64}(ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|4,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 58, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|2,2,0], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 52, ACE1.PIBasisFcn{1, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[22|2,0,0],), ACE1.RPI.PSH1pBasisFcn) =&gt; 8, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|2,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 46, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,1,-1], znlm[13|1,1,1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 27, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,1,-1], znlm[22|2,1,1]), ACE1.RPI.PSH1pBasisFcn) =&gt; 30, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,2,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 40, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,0,0], znlm[22|1,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 103, ACE1.PIBasisFcn{3, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|1,0,0], znlm[13|1,0,0], znlm[22|2,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 84, ACE1.PIBasisFcn{2, ACE1.RPI.PSH1pBasisFcn}(&lt;22&gt;, (znlm[13|2,0,0], znlm[22|1,0,0]), ACE1.RPI.PSH1pBasisFcn) =&gt; 44…), Dict{Any, Int64}(znlm[13|1,3,2] =&gt; 15, znlm[13|1,1,0] =&gt; 3, znlm[13|3,0,0] =&gt; 26, znlm[13|4,1,0] =&gt; 37, znlm[13|1,2,0] =&gt; 7, znlm[22|5,0,0] =&gt; 79, znlm[13|2,0,0] =&gt; 17, znlm[13|4,1,-1] =&gt; 36, znlm[22|1,2,0] =&gt; 47, znlm[13|2,2,2] =&gt; 25…), 137:272, &lt;22&gt;, ACE1.DAG.CorrEvalGraph{Int64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0  …  127, 128, 129, 130, 131, 132, 133, 134, 135, 136], 80, 104))), ACE1.DAGEvaluator()), ([-0.2493509532627468, 0.0021100994685823403, -0.2359679588351114, 0.23618376377479985, -0.1484111692203888, -0.006195339038258602, -0.30181177139179577, 0.40850801236386397, -0.1838797772438533, 0.1440261933243902  …  -0.034410014060155175, 0.0, -0.022308356215739164, -0.011817840582124907, 0.006829439173885732, -0.10082791820413135, 0.05041395910206566, -0.0002909010834233164, 0.04892688750141083, -0.026606568360825433], [-0.3018117713917882, 0.4085080123638145, -0.18387977724386845, 0.14402619332444036, 0.1886800905311468, 0.06184275193773647, -0.21369208481291369, 0.19020779034214697, -0.2197469411285569, 0.06878690389108115  …  0.03305567204752798, 0.0, -0.007481059993748227, 0.041758780076407195, 0.02614385974160214, -0.057178846003364155, 0.02858942300168207, -0.004782405834453638, -0.011639801376188794, -0.003296415580194045]), (ACE1.DAG.CorrEvalGraph{Float64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [-0.2493509532627468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  -0.034410014060155175, 0.0, -0.022308356215739164, -0.011817840582124907, 0.006829439173885732, -0.10082791820413135, 0.05041395910206566, -0.0002909010834233164, 0.04892688750141083, -0.026606568360825433], 80, 104), ACE1.DAG.CorrEvalGraph{Float64, Int64}([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0)  …  (100, 41), (100, 47), (100, 57), (100, 66), (100, 75), (41, 102), (41, 103), (101, 57), (101, 66), (104, 57)], [-0.3018117713917882, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.03305567204752798, 0.0, -0.007481059993748227, 0.041758780076407195, 0.02614385974160214, -0.057178846003364155, 0.02858942300168207, -0.004782405834453638, -0.011639801376188794, -0.003296415580194045], 80, 104)), ACE1.DAGEvaluator(), nothing)])</code></pre><p>We can display an error table as follows:</p><pre><code class="language-julia hljs">@info(&quot;Training Error Table&quot;)
ACE1pack.linear_errors(train, potential);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Training Error Table
[ Info: RMSE Table
┌────────────┬─────────┬──────────┬─────────┐
│       Type │ E [meV] │ F [eV/A] │ V [meV] │
├────────────┼─────────┼──────────┼─────────┤
│   FLD_TiAl │  48.539 │    0.083 │  62.914 │
│ TiAl_T5000 │   5.123 │    0.298 │   2.281 │
├────────────┼─────────┼──────────┼─────────┤
│        set │  47.436 │    0.255 │  61.470 │
└────────────┴─────────┴──────────┴─────────┘
[ Info: MAE Table
┌────────────┬─────────┬──────────┬─────────┐
│       Type │ E [meV] │ F [eV/A] │ V [meV] │
├────────────┼─────────┼──────────┼─────────┤
│   FLD_TiAl │  47.397 │    0.050 │  36.126 │
│ TiAl_T5000 │   4.800 │    0.229 │   1.501 │
├────────────┼─────────┼──────────┼─────────┤
│        set │  45.461 │    0.177 │  34.552 │
└────────────┴─────────┴──────────┴─────────┘</code></pre><p>We should of course also look at test errors, which can be done as follows. Depending on the choice of solver, and solver parameters, the test errors might be very poor. Exploring different parameters in different applications can lead to significantly improved predictions.</p><pre><code class="language-julia hljs">@info(&quot;Test Error Table&quot;)
test = [ACE1pack.AtomsData(d,&quot;energy&quot;,&quot;force&quot;,&quot;virial&quot;,weights,Vref) for d in data[2:10:end]]
ACE1pack.linear_errors(test, potential);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Test Error Table
[ Info: RMSE Table
┌────────────┬─────────┬──────────┬─────────┐
│       Type │ E [meV] │ F [eV/A] │ V [meV] │
├────────────┼─────────┼──────────┼─────────┤
│   FLD_TiAl │  52.702 │    0.148 │ 100.271 │
│ TiAl_T5000 │  17.305 │    0.356 │  89.080 │
├────────────┼─────────┼──────────┼─────────┤
│        set │  51.985 │    0.264 │  99.950 │
└────────────┴─────────┴──────────┴─────────┘
[ Info: MAE Table
┌────────────┬─────────┬──────────┬─────────┐
│       Type │ E [meV] │ F [eV/A] │ V [meV] │
├────────────┼─────────┼──────────┼─────────┤
│   FLD_TiAl │  51.336 │    0.076 │  52.698 │
│ TiAl_T5000 │  17.305 │    0.278 │  72.232 │
├────────────┼─────────┼──────────┼─────────┤
│        set │  50.305 │    0.168 │  53.289 │
└────────────┴─────────┴──────────┴─────────┘</code></pre><p>If we want to save the fitted potentials to disk to later use we can use one of the following commands: the first saves the potential as an <code>ACE1.jl</code> compatible potential, while the second line exports it to a format that can be ready by the <code>pacemaker</code> code to be used within LAMMPS.</p><pre><code class="language-julia hljs">save_dict(&quot;./TiAl_tutorial_pot.json&quot;, Dict(&quot;IP&quot; =&gt; write_dict(potential)))
ACE1pack.ExportMulti.export_ACE(&quot;./TiAl_tutorial_pot.yace&quot;, potential; export_pairpot_as_table=true)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../first_example_model/">« First example (Julia) - <code>acemodel</code></a><a class="docs-footer-nextpage" href="../TiAl_model/">Fitting a TiAl potential (Julia) - <code>acemodel</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 5 February 2023 06:34">Sunday 5 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
